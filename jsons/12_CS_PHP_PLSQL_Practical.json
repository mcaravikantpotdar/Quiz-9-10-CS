{
  "metadata": {
    "chapter_numbers": [4, 6],
    "chapter_title": "PHP & PL/SQL Practical Logic (High Fidelity)",
    "chapter_title_hindi": "PHP और PL/SQL प्रैक्टिकल लॉजिक (उच्च-मानक)",
    "subject": "Computer Science - Class 12",
    "board": "HPBOSE",
    "total_questions": 35,
    "version": "2.0",
    "naming_convention": "12_CS_PHP_PLSQL_Practical.json"
  },
  "questions": [
    {
      "question_id": 1,
      "question": {
        "en": "Predict the output of the following PHP string operation:\n\n&lt;?php\n  $S1 = 'I love';\n  $S2 = ' India';\n  $S3 = $S1 . $S2;\n  echo $S3 . ' always';\n?&gt;",
        "hi": "निम्नलिखित PHP स्ट्रिंग संक्रिया (string operation) के आउटपुट का अनुमान लगाएं:\n\n&lt;?php\n  $S1 = 'I love';\n  $S2 = ' India';\n  $S3 = $S1 . $S2;\n  echo $S3 . ' always';\n?&gt;"
      },
      "options": {
        "a": {"en": "I loveIndia always", "hi": "I loveIndia always"},
        "b": {"en": "I love India always", "hi": "I love India always"},
        "c": {"en": "I love Indiaalways", "hi": "I love Indiaalways"},
        "d": {"en": "Error: . operator usage", "hi": "एरर: . ऑपरेटर का उपयोग"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Check the space before 'India' in $S2 and the space before 'always'.",
        "hi": "$S2 में 'India' से पहले के स्पेस और 'always' से पहले के स्पेस की जाँच करें।"
      },
      "explanation": {
        "en": "Step 1: $S1 + $S2 = 'I love' + ' India' = 'I love India'. Step 2: Adding ' always' (with a space) results in 'I love India always'.",
        "hi": "चरण 1: $S1 + $S2 = 'I love' + ' India' = 'I love India'। चरण 2: ' always' (स्पेस के साथ) जोड़ने पर 'I love India always' प्राप्त होता है।"
      },
      "key_takeaway": {
        "en": "The dot (.) operator in PHP joins strings exactly as they are, including spaces.",
        "hi": "PHP में डॉट (.) ऑपरेटर स्ट्रिंग्स को बिल्कुल वैसे ही जोड़ता है जैसे वे हैं, स्पेस सहित।"
      }
    },
    {
      "question_id": 2,
      "question": {
        "en": "Identify the output of this PL/SQL concatenation trace:\n\nDECLARE\n  S1 VARCHAR2(10) := 'Data';\n  S2 VARCHAR2(10) := 'base';\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(S1 || S2);\nEND;",
        "hi": "इस PL/SQL कॉन्केटनेशन ट्रेस के आउटपुट की पहचान करें:\n\nDECLARE\n  S1 VARCHAR2(10) := 'Data';\n  S2 VARCHAR2(10) := 'base';\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(S1 || S2);\nEND;"
      },
      "options": {
        "a": {"en": "Data base", "hi": "Data base"},
        "b": {"en": "Database", "hi": "Database"},
        "c": {"en": "Data||base", "hi": "Data||base"},
        "d": {"en": "Error: || not valid", "hi": "एरर: || मान्य नहीं है"}
      },
      "correct_option": "b",
      "hint": {
        "en": "PL/SQL uses '||' for joining. Are there any spaces in 'Data' or 'base'?",
        "hi": "PL/SQL जोड़ने के लिए '||' का उपयोग करता है। क्या 'Data' या 'base' में कोई स्पेस है?"
      },
      "explanation": {
        "en": "The || operator joins strings. Since there is no space inside the single quotes ('Data' and 'base'), they are joined directly to form 'Database'.",
        "hi": "|| ऑपरेटर स्ट्रिंग्स को जोड़ता है। चूंकि सिंगल कोट्स ('Data' और 'base') के अंदर कोई स्पेस नहीं है, वे सीधे जुड़कर 'Database' बनाते हैं।"
      },
      "key_takeaway": {
        "en": "|| is the standard PL/SQL string joiner, functionally identical to PHP's dot (.).",
        "hi": "|| मानक PL/SQL स्ट्रिंग जॉइनर है, जो कार्यात्मक रूप से PHP के डॉट (.) के समान है।"
      }
    },
    {
      "question_id": 3,
      "question": {
        "en": "What is the result of the following PHP arithmetic trace?\n\n&lt;?php\n  $a = 10;\n  $b = 3;\n  echo ($a * $b) + ($a % $b);\n?&gt;",
        "hi": "निम्नलिखित PHP अंकगणितीय ट्रेस (arithmetic trace) का परिणाम क्या है?\n\n&lt;?php\n  $a = 10;\n  $b = 3;\n  echo ($a * $b) + ($a % $b);\n?&gt;"
      },
      "options": {
        "a": {"en": "30", "hi": "30"},
        "b": {"en": "31", "hi": "31"},
        "c": {"en": "33", "hi": "33"},
        "d": {"en": "1", "hi": "1"}
      },
      "correct_option": "b",
      "hint": {
        "en": "First multiply 10 and 3, then find the remainder of 10 divided by 3.",
        "hi": "पहले 10 और 3 को गुणा करें, फिर 10 को 3 से विभाजित करने पर शेषफल ज्ञात करें।"
      },
      "explanation": {
        "en": "Step 1: (10 * 3) = 30. Step 2: (10 % 3) = 1 (remainder). Step 3: 30 + 1 = 31.",
        "hi": "चरण 1: (10 * 3) = 30। चरण 2: (10 % 3) = 1 (शेषफल)। चरण 3: 30 + 1 = 31।"
      },
      "key_takeaway": {
        "en": "% operator in PHP returns the remainder of an integer division.",
        "hi": "PHP में % ऑपरेटर पूर्णांक विभाजन (integer division) का शेषफल लौटाता है।"
      }
    },
    {
      "question_id": 4,
      "question": {
        "en": "In PL/SQL, which code correctly calculates the remainder of 10 divided by 3?",
        "hi": "PL/SQL में, कौन सा कोड 10 को 3 से विभाजित करने पर शेषफल की सही गणना करता है?"
      },
      "options": {
        "a": {"en": "10 % 3", "hi": "10 % 3"},
        "b": {"en": "MOD(10, 3)", "hi": "MOD(10, 3)"},
        "c": {"en": "REMAINDER(10, 3)", "hi": "REMAINDER(10, 3)"},
        "d": {"en": "10 MOD 3", "hi": "10 MOD 3"}
      },
      "correct_option": "b",
      "hint": {
        "en": "PL/SQL uses a built-in function instead of a percentage symbol.",
        "hi": "PL/SQL प्रतिशत प्रतीक के बजाय एक इन-बिल्ट फंक्शन का उपयोग करता है।"
      },
      "explanation": {
        "en": "The MOD function in PL/SQL takes two parameters: the value and the divisor. MOD(10, 3) returns 1.",
        "hi": "PL/SQL में MOD फंक्शन दो पैरामीटर लेता है: मान और भाजक। MOD(10, 3) 1 लौटाता है।"
      },
      "key_takeaway": {
        "en": "PL/SQL Remainder = MOD(a, b).",
        "hi": "PL/SQL शेषफल = MOD(a, b)।"
      }
    },
    {
      "question_id": 5,
      "question": {
        "en": "Trace the logic: What is the output if $marks = 33?\n\n&lt;?php\n  $marks = 33;\n  if ($marks &gt; 33)\n  {\n      echo 'Pass';\n  }\n  else\n  {\n      echo 'Fail';\n  }\n?&gt;",
        "hi": "लॉजिक ट्रेस करें: यदि $marks = 33 है तो आउटपुट क्या है?\n\n&lt;?php\n  $marks = 33;\n  if ($marks &gt; 33)\n  {\n      echo 'Pass';\n  }\n  else\n  {\n      echo 'Fail';\n  }\n?&gt;"
      },
      "options": {
        "a": {"en": "Pass", "hi": "Pass"},
        "b": {"en": "Fail", "hi": "Fail"},
        "c": {"en": "33", "hi": "33"},
        "d": {"en": "No output", "hi": "कोई आउटपुट नहीं"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Is 33 strictly greater than 33? Check the operator carefully.",
        "hi": "क्या 33 वास्तव में 33 से बड़ा है? ऑपरेटर को ध्यान से जाँचें।"
      },
      "explanation": {
        "en": "The condition ($marks > 33) is FALSE because 33 is equal to 33, not greater. Therefore, the 'else' block executes.",
        "hi": "शर्त ($marks > 33) FALSE है क्योंकि 33, 33 के बराबर है, उससे बड़ा नहीं। इसलिए, 'else' ब्लॉक निष्पादित होता है।"
      },
      "key_takeaway": {
        "en": "The &gt; operator excludes the comparison value. Use &gt;= to include it.",
        "hi": "&gt; ऑपरेटर तुलनात्मक मान को बाहर रखता है। उसे शामिल करने के लिए &gt;= का उपयोग करें।"
      }
    },
    {
      "question_id": 6,
      "question": {
        "en": "What is the syntax error in the following PL/SQL block?\n\nDECLARE\n  age NUMBER := 20;\nBEGIN\n  IF (age &gt;= 18)\n    DBMS_OUTPUT.PUT_LINE('Adult');\n  END IF;\nEND;",
        "hi": "निम्नलिखित PL/SQL ब्लॉक में सिंटैक्स एरर क्या है?\n\nDECLARE\n  age NUMBER := 20;\nBEGIN\n  IF (age &gt;= 18)\n    DBMS_OUTPUT.PUT_LINE('Adult');\n  END IF;\nEND;"
      },
      "options": {
        "a": {"en": "Missing THEN keyword after the condition", "hi": "कंडीशन के बाद THEN कीवर्ड गायब है"},
        "b": {"en": "Missing BEGIN after IF", "hi": "IF के बाद BEGIN गायब है"},
        "c": {"en": "DBMS_OUTPUT is not a valid command", "hi": "DBMS_OUTPUT एक मान्य कमांड नहीं है"},
        "d": {"en": "No error", "hi": "कोई त्रुटि नहीं"}
      },
      "correct_option": "a",
      "hint": {
        "en": "Every IF statement in PL/SQL must be followed by a specific keyword before the action.",
        "hi": "PL/SQL में प्रत्येक IF स्टेटमेंट के बाद क्रिया (action) से पहले एक विशिष्ट कीवर्ड होना चाहिए।"
      },
      "explanation": {
        "en": "In PL/SQL, the correct syntax is 'IF (condition) THEN'. The code in the question is missing the mandatory 'THEN' keyword.",
        "hi": "PL/SQL में, सही सिंटैक्स 'IF (condition) THEN' है। प्रश्न के कोड में अनिवार्य 'THEN' कीवर्ड गायब है।"
      },
      "key_takeaway": {
        "en": "PL/SQL IF syntax: IF &lt;cond&gt; THEN &lt;code&gt; END IF;.",
        "hi": "PL/SQL IF सिंटैक्स: IF &lt;cond&gt; THEN &lt;code&gt; END IF;।"
      }
    },
    {
      "question_id": 7,
      "question": {
        "en": "Predict the output of the following PHP Switch-Case trace:\n\n&lt;?php\n  $day = 2;\n  switch ($day) \n  {\n      case 1: echo 'Mon'; break;\n      case 2: echo 'Tue';\n      case 3: echo 'Wed'; break;\n      default: echo 'None';\n  }\n?&gt;",
        "hi": "निम्नलिखित PHP स्विच-केस ट्रेस के आउटपुट का अनुमान लगाएं:\n\n&lt;?php\n  $day = 2;\n  switch ($day) \n  {\n      case 1: echo 'Mon'; break;\n      case 2: echo 'Tue';\n      case 3: echo 'Wed'; break;\n      default: echo 'None';\n  }\n?&gt;"
      },
      "options": {
        "a": {"en": "Tue", "hi": "Tue"},
        "b": {"en": "TueWed", "hi": "TueWed"},
        "c": {"en": "TueNone", "hi": "TueNone"},
        "d": {"en": "Wed", "hi": "Wed"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Check if there is a 'break' statement in case 2.",
        "hi": "जाँचें कि क्या केस 2 में 'break' स्टेटमेंट है।"
      },
      "explanation": {
        "en": "Since 'case 2' is missing the 'break' statement, PHP executes 'case 2' and then 'falls through' to execute 'case 3' as well.",
        "hi": "चूंकि 'केस 2' में 'break' स्टेटमेंट नहीं है, PHP 'केस 2' को निष्पादित करता है और फिर 'केस 3' को भी निष्पादित करने के लिए आगे बढ़ जाता है।"
      },
      "key_takeaway": {
        "en": "A missing 'break' results in 'fall-through', where subsequent cases are executed regardless of a match.",
        "hi": "'break' न होने से 'fall-through' होता है, जहाँ मैच की परवाह किए बिना अगले केस निष्पादित किए जाते हैं।"
      }
    },
    {
      "question_id": 8,
      "question": {
        "en": "Which of the following is the correct PL/SQL syntax for multiple conditions (equivalent to PHP's elseif)?",
        "hi": "निम्नलिखित में से कौन सा कई शर्तों (PHP के elseif के समकक्ष) के लिए सही PL/SQL सिंटैक्स है?"
      },
      "options": {
        "a": {"en": "ELSE IF (cond) THEN", "hi": "ELSE IF (cond) THEN"},
        "b": {"en": "ELSEIF (cond) THEN", "hi": "ELSEIF (cond) THEN"},
        "c": {"en": "ELSIF (cond) THEN", "hi": "ELSIF (cond) THEN"},
        "d": {"en": "ELIF (cond) THEN", "hi": "ELIF (cond) THEN"}
      },
      "correct_option": "c",
      "hint": {
        "en": "It is a single word, but the letter 'E' is removed from the middle of ELSE.",
        "hi": "यह एक शब्द है, लेकिन ELSE के बीच से 'E' अक्षर हटा दिया गया है।"
      },
      "explanation": {
        "en": "PL/SQL uses the specific keyword 'ELSIF'. Note the spelling: there is no 'E' after 'S'.",
        "hi": "PL/SQL विशिष्ट कीवर्ड 'ELSIF' का उपयोग करता है। स्पेलिंग पर ध्यान दें: 'S' के बाद कोई 'E' नहीं है।"
      },
      "key_takeaway": {
        "en": "PL/SQL spelling: ELSIF (Correct) vs ELSEIF (Incorrect).",
        "hi": "PL/SQL स्पेलिंग: ELSIF (सही) बनाम ELSEIF (गलत)।"
      }
    },
    {
      "question_id": 9,
      "question": {
        "en": "Dry Run: What is the final value of $SUM in this PHP loop?\n\n&lt;?php\n  $N = 1;\n  $SUM = 0;\n  while ($N &lt; 4)\n  {\n      $SUM = $SUM + $N;\n      $N++;\n  }\n?&gt;",
        "hi": "ड्राय रन: इस PHP लूप में $SUM का अंतिम मान क्या है?\n\n&lt;?php\n  $N = 1;\n  $SUM = 0;\n  while ($N &lt; 4)\n  {\n      $SUM = $SUM + $N;\n      $N++;\n  }\n?&gt;"
      },
      "options": {
        "a": {"en": "3", "hi": "3"},
        "b": {"en": "6", "hi": "6"},
        "c": {"en": "10", "hi": "10"},
        "d": {"en": "4", "hi": "4"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Step 1: 0+1=1. Step 2: 1+2=3. Step 3: 3+3=6. Does it run when N is 4?",
        "hi": "चरण 1: 0+1=1। चरण 2: 1+2=3। चरण 3: 3+3=6। क्या यह तब चलता है जब N 4 होता है?"
      },
      "explanation": {
        "en": "Iteration 1: N=1, SUM=1. Iteration 2: N=2, SUM=3. Iteration 3: N=3, SUM=6. When N=4, the condition (4 < 4) is FALSE, so the loop stops.",
        "hi": "राउंड 1: N=1, SUM=1। राउंड 2: N=2, SUM=3। राउंड 3: N=3, SUM=6। जब N=4 होता है, तो शर्त (4 < 4) FALSE होती है, इसलिए लूप रुक जाता है।"
      },
      "key_takeaway": {
        "en": "The &lt; operator stops the loop before reaching the comparison value.",
        "hi": "&lt; ऑपरेटर तुलनात्मक मान तक पहुँचने से पहले लूप को रोक देता है।"
      }
    },
    {
      "question_id": 10,
      "question": {
        "en": "What is the equivalent of PHP's 'do-while' loop in PL/SQL?",
        "hi": "PL/SQL में PHP के 'do-while' लूप के समकक्ष क्या है?"
      },
      "options": {
        "a": {"en": "WHILE ... LOOP", "hi": "WHILE ... LOOP"},
        "b": {"en": "LOOP ... EXIT WHEN ... END LOOP;", "hi": "LOOP ... EXIT WHEN ... END LOOP;"},
        "c": {"en": "FOR ... IN ... LOOP", "hi": "FOR ... IN ... LOOP"},
        "d": {"en": "DO ... WHILE", "hi": "DO ... WHILE"}
      },
      "correct_option": "b",
      "hint": {
        "en": "This is called a Basic Loop, where the exit condition is inside the block.",
        "hi": "इसे बेसिक लूप (Basic Loop) कहा जाता है, जहाँ बाहर निकलने की शर्त ब्लॉक के अंदर होती है।"
      },
      "explanation": {
        "en": "A Basic Loop executes the code and then checks the 'EXIT WHEN' condition, similar to how 'do-while' checks the condition after one execution.",
        "hi": "एक बेसिक लूप कोड को निष्पादित करता है और फिर 'EXIT WHEN' शर्त की जाँच करता है, वैसे ही जैसे 'do-while' एक बार निष्पादन के बाद शर्त की जाँच करता है।"
      },
      "key_takeaway": {
        "en": "PL/SQL Basic Loop + EXIT WHEN = Exit-controlled loop.",
        "hi": "PL/SQL बेसिक लूप + EXIT WHEN = एग्जिट-कंट्रोल्ड लूप।"
      }
    },
    {
      "question_id": 11,
      "question": {
        "en": "Identify the output of this PL/SQL loop trace:\n\nDECLARE\n  i NUMBER := 1;\nBEGIN\n  LOOP\n    DBMS_OUTPUT.PUT_LINE(i * 10);\n    i := i + 1;\n    EXIT WHEN i &gt; 3;\n  END LOOP;\nEND;",
        "hi": "इस PL/SQL लूप ट्रेस के आउटपुट की पहचान करें:\n\nDECLARE\n  i NUMBER := 1;\nBEGIN\n  LOOP\n    DBMS_OUTPUT.PUT_LINE(i * 10);\n    i := i + 1;\n    EXIT WHEN i &gt; 3;\n  END LOOP;\nEND;"
      },
      "options": {
        "a": {"en": "10 20", "hi": "10 20"},
        "b": {"en": "10 20 30", "hi": "10 20 30"},
        "c": {"en": "30", "hi": "30"},
        "d": {"en": "10 20 30 40", "hi": "10 20 30 40"}
      },
      "correct_option": "b",
      "hint": {
        "en": "The loop exits ONLY WHEN i becomes greater than 3.",
        "hi": "लूप केवल तभी बाहर निकलता है जब i 3 से बड़ा हो जाता है।"
      },
      "explanation": {
        "en": "Step 1: i=1, prints 10. Step 2: i=2, prints 20. Step 3: i=3, prints 30. Step 4: i becomes 4, checks (4 > 3) which is True, exits loop.",
        "hi": "चरण 1: i=1, 10 प्रिंट करता है। चरण 2: i=2, 20 प्रिंट करता है। चरण 3: i=3, 30 प्रिंट करता है। चरण 4: i 4 हो जाता है, जाँचता है (4 > 3) जो सत्य है, लूप से बाहर निकल जाता है।"
      },
      "key_takeaway": {
        "en": "EXIT WHEN works like a 'break' based on a condition.",
        "hi": "EXIT WHEN किसी शर्त के आधार पर 'break' की तरह काम करता है।"
      }
    },
    {
      "question_id": 12,
      "question": {
        "en": "Fibonacci Trace: If $PRV=0$ and $NXT=1$, what is the calculated $SUM$ and the updated value of $NXT$ after one step of the loop logic?\n\n$SUM = $PRV + $NXT;\n$PRV = $NXT;\n$NXT = $SUM;",
        "hi": "फाइबोनैचि ट्रेस: यदि $PRV=0$ और $NXT=1$ है, तो लूप लॉजिक के एक चरण के बाद गणना की गई $SUM$ और $NXT$ का अपडेटेड मान क्या होगा?\n\n$SUM = $PRV + $NXT;\n$PRV = $NXT;\n$NXT = $SUM;"
      },
      "options": {
        "a": {"en": "SUM=1, NXT=1", "hi": "SUM=1, NXT=1"},
        "b": {"en": "SUM=1, NXT=2", "hi": "SUM=1, NXT=2"},
        "c": {"en": "SUM=0, NXT=1", "hi": "SUM=0, NXT=1"},
        "d": {"en": "SUM=2, NXT=1", "hi": "SUM=2, NXT=1"}
      },
      "correct_option": "a",
      "hint": {
        "en": "The next value is the sum of current two. Then current becomes previous.",
        "hi": "अगला मान वर्तमान दो का योग है। फिर वर्तमान पिछला बन जाता है।"
      },
      "explanation": {
        "en": "Step 1: SUM = 0+1 = 1. Step 2: PRV takes NXT (1). Step 3: NXT takes SUM (1). Final state: SUM=1, NXT=1.",
        "hi": "चरण 1: SUM = 0+1 = 1। चरण 2: PRV, NXT (1) लेता है। चरण 3: NXT, SUM (1) लेता है। अंतिम अवस्था: SUM=1, NXT=1।"
      },
      "key_takeaway": {
        "en": "The Fibonacci logic requires shifting variable values forward in each iteration.",
        "hi": "फाइबोनैचि लॉजिक में प्रत्येक राउंड में वेरिएबल के मानों को आगे खिसकाना आवश्यक होता है।"
      }
    },
    {
      "question_id": 13,
      "question": {
        "en": "What is the output for finding the area of a circle with $Rad = 10$ in PHP?\n\n&lt;?php\n  $Rad = 10;\n  echo 3.14 * $Rad ** 2;\n?&gt;",
        "hi": "$Rad = 10$ के साथ PHP में वृत्त का क्षेत्रफल ज्ञात करने का आउटपुट क्या है?\n\n&lt;?php\n  $Rad = 10;\n  echo 3.14 * $Rad ** 2;\n?&gt;"
      },
      "options": {
        "a": {"en": "31.4", "hi": "31.4"},
        "b": {"en": "314", "hi": "314"},
        "c": {"en": "100", "hi": "100"},
        "d": {"en": "62.8", "hi": "62.8"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Square the radius first (10*10), then multiply by 3.14.",
        "hi": "पहले त्रिज्या का वर्ग (10*10) करें, फिर 3.14 से गुणा करें।"
      },
      "explanation": {
        "en": "10 squared is 100. 3.14 * 100 = 314. This follows the formula πr².",
        "hi": "10 का वर्ग 100 है। 3.14 * 100 = 314। यह सूत्र πr² का अनुसरण करता है।"
      },
      "key_takeaway": {
        "en": "** operator is the most concise way to write power in PHP.",
        "hi": "PHP में पावर (power) लिखने का सबसे संक्षिप्त तरीका ** ऑपरेटर है।"
      }
    },
    {
      "question_id": 14,
      "question": {
        "en": "In PL/SQL, how do you handle logical 'OR' when checking multiple conditions?\n\nIF (A &gt; B ______ A &gt; C) THEN",
        "hi": "PL/SQL में, कई स्थितियों की जाँच करते समय आप लॉजिकल 'OR' को कैसे संभालते हैं?\n\nIF (A &gt; B ______ A &gt; C) THEN"
      },
      "options": {
        "a": {"en": "||", "hi": "||"},
        "b": {"en": "OR", "hi": "OR"},
        "c": {"en": "|", "hi": "|"},
        "d": {"en": "ORIF", "hi": "ORIF"}
      },
      "correct_option": "b",
      "hint": {
        "en": "PL/SQL uses English words for logical gates, not symbols like ||.",
        "hi": "PL/SQL लॉजिकल गेट्स के लिए अंग्रेजी शब्दों का उपयोग करता है, || जैसे प्रतीकों का नहीं।"
      },
      "explanation": {
        "en": "While PHP uses '||', PL/SQL uses the word 'OR' to compare multiple logical expressions.",
        "hi": "जहाँ PHP '||' का उपयोग करता है, वहीं PL/SQL कई तार्किक अभिव्यक्तियों की तुलना करने के लिए 'OR' शब्द का उपयोग करता है।"
      },
      "key_takeaway": {
        "en": "Logical OR: PHP (||) vs PL/SQL (OR).",
        "hi": "लॉजिकल OR: PHP (||) बनाम PL/SQL (OR)।"
      }
    },
    {
      "question_id": 15,
      "question": {
        "en": "Trace: What will be printed if a student has m = 45 in this Grading system?\n\nif ($m &gt;= 50) { echo 'Grade C'; }\nelseif ($m &gt;= 40) { echo 'Grade D'; }\nelse { echo 'Grade E'; }",
        "hi": "ट्रेस करें: यदि इस ग्रेडिंग सिस्टम में किसी छात्र के m = 45 अंक हैं तो क्या प्रिंट होगा?\n\nif ($m &gt;= 50) { echo 'Grade C'; }\nelseif ($m &gt;= 40) { echo 'Grade D'; }\nelse { echo 'Grade E'; }"
      },
      "options": {
        "a": {"en": "Grade C", "hi": "Grade C"},
        "b": {"en": "Grade D", "hi": "Grade D"},
        "c": {"en": "Grade E", "hi": "Grade E"},
        "d": {"en": "Fail", "hi": "Fail"}
      },
      "correct_option": "b",
      "hint": {
        "en": "45 is less than 50 but greater than 40.",
        "hi": "45, 50 से कम है लेकिन 40 से बड़ा है।"
      },
      "explanation": {
        "en": "The code first checks >= 50 (False for 45). Then it checks >= 40 (True for 45). It prints 'Grade D' and exits the chain.",
        "hi": "कोड पहले >= 50 की जाँच करता है (45 के लिए गलत)। फिर यह >= 40 की जाँच करता है (45 के लिए सही)। यह 'Grade D' प्रिंट करता है और चेन से बाहर निकल जाता है।"
      },
      "key_takeaway": {
        "en": "elseif chains ensure only the first matching category executes.",
        "hi": "elseif चेन यह सुनिश्चित करती है कि केवल पहली मिलान वाली श्रेणी ही निष्पादित हो।"
      }
    },
    {
      "question_id": 16,
      "question": {
        "en": "Dry Run: Calculate the final value of 'SUM' after three iterations of this loop.\n\nDECLARE\n  SUM NUMBER := 0;\nBEGIN\n  FOR i IN 1..3 LOOP\n    SUM := SUM + (i * 2);\n  END LOOP;\nEND;",
        "hi": "ड्राय रन: इस लूप के तीन राउंड के बाद 'SUM' के अंतिम मान की गणना करें।\n\nDECLARE\n  SUM NUMBER := 0;\nBEGIN\n  FOR i IN 1..3 LOOP\n    SUM := SUM + (i * 2);\n  END LOOP;\nEND;"
      },
      "options": {
        "a": {"en": "6", "hi": "6"},
        "b": {"en": "10", "hi": "10"},
        "c": {"en": "12", "hi": "12"},
        "d": {"en": "15", "hi": "15"}
      },
      "correct_option": "c",
      "hint": {
        "en": "Trace: i=1 (0+2=2), i=2 (2+4=6), i=3 (6+6=?).",
        "hi": "ट्रेस: i=1 (0+2=2), i=2 (2+4=6), i=3 (6+6=?)।"
      },
      "explanation": {
        "en": "Round 1: i=1, SUM = 0 + 2 = 2. Round 2: i=2, SUM = 2 + 4 = 6. Round 3: i=3, SUM = 6 + 6 = 12. Final result is 12.",
        "hi": "राउंड 1: i=1, SUM = 0 + 2 = 2। राउंड 2: i=2, SUM = 2 + 4 = 6। राउंड 3: i=3, SUM = 6 + 6 = 12। अंतिम परिणाम 12 है।"
      },
      "key_takeaway": {
        "en": "FOR loops manage the counter automatically; SUM accumulates the results.",
        "hi": "FOR लूप काउंटर को स्वचालित रूप से प्रबंधित करते हैं; SUM परिणामों को संचित करता है।"
      }
    },
    {
      "question_id": 17,
      "question": {
        "en": "In the number series (3, 8, 13 ... 48), what logic correctly updates N in a PHP loop?",
        "hi": "संख्या सीरीज (3, 8, 13 ... 48) में, कौन सा लॉजिक PHP लूप में N को सही ढंग से अपडेट करता है?"
      },
      "options": {
        "a": {"en": "$N = $N + 1;", "hi": "$N = $N + 1;"},
        "b": {"en": "$N++;", "hi": "$N++;"},
        "c": {"en": "$N = $N + 5;", "hi": "$N = $N + 5;"},
        "d": {"en": "$N = $N + 3;", "hi": "$N = $N + 3;"}
      },
      "correct_option": "c",
      "hint": {
        "en": "Calculate the difference between 3 and 8.",
        "hi": "3 और 8 के बीच के अंतर की गणना करें।"
      },
      "explanation": {
        "en": "The interval between numbers (8-3) is 5. Therefore, N must be increased by 5 in each step.",
        "hi": "संख्याओं (8-3) के बीच का अंतराल 5 है। इसलिए, प्रत्येक चरण में N को 5 से बढ़ाया जाना चाहिए।"
      },
      "key_takeaway": {
        "en": "Step value defines the progression of a series.",
        "hi": "स्टेप वैल्यू (Step value) सीरीज की प्रगति को परिभाषित करती है।"
      }
    },
    {
      "question_id": 18,
      "question": {
        "en": "Predict the result of this concatenated operation in PHP:\n\necho 10 . 20 + 30;",
        "hi": "PHP में इस कॉन्केटनेटेड ऑपरेशन के परिणाम का अनुमान लगाएं:\n\necho 10 . 20 + 30;"
      },
      "options": {
        "a": {"en": "1050", "hi": "1050"},
        "b": {"en": "60", "hi": "60"},
        "c": {"en": "102030", "hi": "102030"},
        "d": {"en": "Error", "hi": "Error"}
      },
      "correct_option": "a",
      "hint": {
        "en": "Math addition (+) happens before string concatenation (.) in standard PHP precedence.",
        "hi": "मानक PHP प्राथमिकता में स्ट्रिंग कॉन्केटनेशन (.) से पहले गणितीय जोड़ (+) होता है।"
      },
      "explanation": {
        "en": "Step 1: 20 + 30 = 50. Step 2: The number 10 is joined to 50 as a string. Result: '1050'.",
        "hi": "चरण 1: 20 + 30 = 50। चरण 2: नंबर 10 को स्ट्रिंग के रूप में 50 के साथ जोड़ा जाता है। परिणाम: '1050'।"
      },
      "key_takeaway": {
        "en": "Operator precedence affects how numbers are joined or added.",
        "hi": "ऑपरेटर प्राथमिकता प्रभावित करती है कि नंबर कैसे जोड़े जाते हैं।"
      }
    },
    {
      "question_id": 19,
      "question": {
        "en": "Which statement correctly prints 'TRUE' for the equality of 5 and '5' in PL/SQL?",
        "hi": "PL/SQL में 5 और '5' की समानता के लिए कौन सा स्टेटमेंट सही ढंग से 'TRUE' प्रिंट करता है?"
      },
      "options": {
        "a": {"en": "IF (5 == '5')", "hi": "IF (5 == '5')"},
        "b": {"en": "IF (5 = '5')", "hi": "IF (5 = '5')"},
        "c": {"en": "IF (5 === '5')", "hi": "IF (5 === '5')"},
        "d": {"en": "IF (5 := '5')", "hi": "IF (5 := '5')"}
      },
      "correct_option": "b",
      "hint": {
        "en": "PL/SQL uses a single equals sign for comparison and handles type conversion.",
        "hi": "PL/SQL तुलना के लिए सिंगल इक्वल्स साइन का उपयोग करता है और डेटा टाइप परिवर्तन को संभालता है।"
      },
      "explanation": {
        "en": "In PL/SQL, the '=' operator is used for comparison in IF statements. It will automatically convert the string to a number to check for equality.",
        "hi": "PL/SQL में, IF स्टेटमेंट में तुलना के लिए '=' ऑपरेटर का उपयोग किया जाता है। समानता जाँचने के लिए यह स्ट्रिंग को स्वचालित रूप से नंबर में बदल देगा।"
      },
      "key_takeaway": {
        "en": "= is for comparison in PL/SQL; := is for assignment.",
        "hi": "= PL/SQL में तुलना के लिए है; := असाइनमेंट के लिए है।"
      }
    },
    {
      "question_id": 20,
      "question": {
        "en": "Trace this loop: What is the last number printed?\n\n&lt;?php\n  for ($i = 50; $i &gt; 40; $i = $i - 5)\n  {\n      echo $i . ' ';\n  }\n?&gt;",
        "hi": "इस लूप को ट्रेस करें: प्रिंट की गई अंतिम संख्या क्या है?\n\n&lt;?php\n  for ($i = 50; $i &gt; 40; $i = $i - 5)\n  {\n      echo $i . ' ';\n  }\n?&gt;"
      },
      "options": {
        "a": {"en": "50", "hi": "50"},
        "b": {"en": "45", "hi": "45"},
        "c": {"en": "40", "hi": "40"},
        "d": {"en": "35", "hi": "35"}
      },
      "correct_option": "b",
      "hint": {
        "en": "The loop runs while i is strictly greater than 40.",
        "hi": "लूप तब तक चलता है जब तक i वास्तव में 40 से बड़ा है।"
      },
      "explanation": {
        "en": "Iteration 1: i=50, 50>40 (True), prints 50. Iteration 2: i=45, 45>40 (True), prints 45. Iteration 3: i=40, 40>40 (False), loop ends. Last number is 45.",
        "hi": "राउंड 1: i=50, 50>40 (सत्य), 50 प्रिंट करता है। राउंड 2: i=45, 45>40 (सत्य), 45 प्रिंट करता है। राउंड 3: i=40, 40>40 (असत्य), लूप समाप्त होता है। अंतिम संख्या 45 है।"
      },
      "key_takeaway": {
        "en": "Descending loops must use proper boundary conditions to avoid infinite execution.",
        "hi": "अवरोही लूप्स में अनंत निष्पादन से बचने के लिए उचित सीमा शर्तों का उपयोग किया जाना चाहिए।"
      }
    },
    {
      "question_id": 21,
      "question": {
        "en": "Which code snippet correctly handles a 'Not Equal' check in PL/SQL?",
        "hi": "कौन सा कोड स्निपेट PL/SQL में 'बराबर नहीं' (Not Equal) की जाँच को सही ढंग से संभालता है?"
      },
      "options": {
        "a": {"en": "IF (x != 10)", "hi": "IF (x != 10)"},
        "b": {"en": "IF (x &lt;&gt; 10)", "hi": "IF (x &lt;&gt; 10)"},
        "c": {"en": "IF (x ~= 10)", "hi": "IF (x ~= 10)"},
        "d": {"en": "All of the above", "hi": "उपरोक्त सभी"}
      },
      "correct_option": "d",
      "hint": {
        "en": "PL/SQL is very flexible with inequality operators.",
        "hi": "PL/SQL असमानता ऑपरेटरों के साथ बहुत लचीला है।"
      },
      "explanation": {
        "en": "Unlike most languages that only support !=, PL/SQL accepts !=, &lt;&gt;, and ~= as valid 'Not Equal' operators.",
        "hi": "अधिकांश भाषाओं के विपरीत जो केवल != का समर्थन करती हैं, PL/SQL !=, &lt;&gt; और ~= को मान्य 'बराबर नहीं' ऑपरेटरों के रूप में स्वीकार करता है।"
      },
      "key_takeaway": {
        "en": "PL/SQL inequality operators: !=, &lt;&gt;, ~=.",
        "hi": "PL/SQL असमानता ऑपरेटर: !=, &lt;&gt;, ~=।"
      }
    },
    {
      "question_id": 22,
      "question": {
        "en": "Predict the output of the Area calculation with $S = 70$ in PHP:\n\n$Area = $S * $S;\necho \"Area is $Area\";",
        "hi": "PHP में $S = 70$ के साथ क्षेत्रफल की गणना के आउटपुट का अनुमान लगाएं:\n\n$Area = $S * $S;\necho \"Area is $Area\";"
      },
      "options": {
        "a": {"en": "Area is 140", "hi": "Area is 140"},
        "b": {"en": "Area is 490", "hi": "Area is 490"},
        "c": {"en": "Area is 4900", "hi": "Area is 4900"},
        "d": {"en": "Area is $Area", "hi": "Area is $Area"}
      },
      "correct_option": "c",
      "hint": {
        "en": "Square of 7 is 49. Double the zeros.",
        "hi": "7 का वर्ग 49 है। शून्य को दोगुना करें।"
      },
      "explanation": {
        "en": "70 * 70 = 4900. In double-quoted strings, PHP replaces the variable name ($Area) with its actual value.",
        "hi": "70 * 70 = 4900। डबल-कोडेड स्ट्रिंग्स में, PHP वेरिएबल नाम ($Area) को उसके वास्तविक मान से बदल देता है।"
      },
      "key_takeaway": {
        "en": "Double quotes allow variable interpolation in PHP.",
        "hi": "डबल कोट्स PHP में वेरिएबल इंटरपोलेशन (interpolation) की अनुमति देते हैं।"
      }
    },
    {
      "question_id": 23,
      "question": {
        "en": "What happens if a user writes 'echo result;' instead of 'echo $result;' in PHP?",
        "hi": "यदि कोई यूजर PHP में 'echo $result;' के बजाय 'echo result;' लिखता है तो क्या होगा?"
      },
      "options": {
        "a": {"en": "It prints the variable value", "hi": "यह वेरिएबल का मान प्रिंट करता है"},
        "b": {"en": "It treats 'result' as a string constant and prints the word 'result'", "hi": "यह 'result' को एक स्ट्रिंग कॉन्स्टेंट के रूप में मानता है और 'result' शब्द प्रिंट करता है"},
        "c": {"en": "It automatically adds the $ sign", "hi": "यह अपने आप $ चिह्न जोड़ देता है"},
        "d": {"en": "It deletes the variable", "hi": "यह वेरिएबल को हटा देता है"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Variables in PHP must have the prefix. Without it, it's just text.",
        "hi": "PHP में वेरिएबल्स में प्रीफ़िक्स होना चाहिए। इसके बिना, यह केवल टेक्स्ट है।"
      },
      "explanation": {
        "en": "Without the '$' sign, PHP assumes 'result' is a string constant (if not defined). It will output the literal text 'result' instead of the variable's data.",
        "hi": "'$' चिह्न के बिना, PHP मान लेता है कि 'result' एक स्ट्रिंग कॉन्स्टेंट है। यह वेरिएबल के डेटा के बजाय 'result' शब्द ही आउटपुट करेगा।"
      },
      "key_takeaway": {
        "en": "$ is a mandatory variable identifier in PHP.",
        "hi": "$ PHP में एक अनिवार्य वेरिएबल पहचानकर्ता है।"
      }
    },
    {
      "question_id": 24,
      "question": {
        "en": "Identify the correct way to output a message in PL/SQL:",
        "hi": "PL/SQL में संदेश आउटपुट करने का सही तरीका पहचानें:"
      },
      "options": {
        "a": {"en": "PUT_LINE('Hello');", "hi": "PUT_LINE('Hello');"},
        "b": {"en": "DBMS_OUTPUT.PUT_LINE('Hello');", "hi": "DBMS_OUTPUT.PUT_LINE('Hello');"},
        "c": {"en": "DBMS.WRITE('Hello');", "hi": "DBMS.WRITE('Hello');"},
        "d": {"en": "echo 'Hello';", "hi": "echo 'Hello';"}
      },
      "correct_option": "b",
      "hint": {
        "en": "It requires the full package name before the procedure name.",
        "hi": "प्रोसीजर नाम से पहले पूरे पैकेज नाम की आवश्यकता होती है।"
      },
      "explanation": {
        "en": "In PL/SQL, output is handled by the DBMS_OUTPUT package. The PUT_LINE procedure prints text on a new line.",
        "hi": "PL/SQL में, आउटपुट DBMS_OUTPUT पैकेज द्वारा नियंत्रित किया जाता है। PUT_LINE प्रोसीजर टेक्स्ट को एक नई लाइन पर प्रिंट करता है।"
      },
      "key_takeaway": {
        "en": "DBMS_OUTPUT.PUT_LINE is the standard console output for PL/SQL.",
        "hi": "DBMS_OUTPUT.PUT_LINE, PL/SQL के लिए मानक कंसोल आउटपुट है।"
      }
    },
    {
      "question_id": 25,
      "question": {
        "en": "Predict the result of the following PHP logic: \n\n$a = true; \n$b = false; \necho ($a &amp;&amp; $b) ? 'Yes' : 'No';",
        "hi": "निम्नलिखित PHP लॉजिक के परिणाम का अनुमान लगाएं: \n\n$a = true; \n$b = false; \necho ($a &amp;&amp; $b) ? 'Yes' : 'No';"
      },
      "options": {
        "a": {"en": "Yes", "hi": "Yes"},
        "b": {"en": "No", "hi": "No"},
        "c": {"en": "true", "hi": "true"},
        "d": {"en": "Error", "hi": "Error"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Logical AND (&&) requires BOTH to be true. One is false.",
        "hi": "लॉजिकल AND (&&) के लिए दोनों का सत्य होना आवश्यक है। एक असत्य (false) है।"
      },
      "explanation": {
        "en": "(true && false) evaluates to FALSE. The ternary operator then selects the 'else' value, which is 'No'.",
        "hi": "(true && false) का मूल्यांकन FALSE के रूप में होता है। टर्नरी ऑपरेटर फिर 'else' मान चुनता है, जो कि 'No' है।"
      },
      "key_takeaway": {
        "en": "Ternary Operator syntax: (condition ? TrueResult : FalseResult).",
        "hi": "टर्नरी ऑपरेटर सिंटैक्स: (condition ? TrueResult : FalseResult)।"
      }
    },
    {
      "question_id": 26,
      "question": {
        "en": "Which PL/SQL loop is guaranteed to execute the code block at least once?",
        "hi": "कौन सा PL/SQL लूप कोड ब्लॉक को कम से कम एक बार निष्पादित करने की गारंटी देता है?"
      },
      "options": {
        "a": {"en": "WHILE LOOP", "hi": "WHILE LOOP"},
        "b": {"en": "FOR LOOP", "hi": "FOR LOOP"},
        "c": {"en": "BASIC LOOP (with exit condition at bottom)", "hi": "बेसिक लूप (नीचे एग्जिट कंडीशन के साथ)"},
        "d": {"en": "None", "hi": "कोई नहीं"}
      },
      "correct_option": "c",
      "hint": {
        "en": "This loop checks the exit condition after running the block.",
        "hi": "यह लूप ब्लॉक चलाने के बाद एग्जिट कंडीशन की जाँच करता है।"
      },
      "explanation": {
        "en": "A Basic Loop in PL/SQL executes its code first, and then evaluates the EXIT WHEN condition, similar to a PHP do-while loop.",
        "hi": "PL/SQL में एक बेसिक लूप पहले अपना कोड निष्पादित करता है, और फिर EXIT WHEN शर्त का मूल्यांकन करता है।"
      },
      "key_takeaway": {
        "en": "Exit-controlled loops ensure initial execution regardless of condition.",
        "hi": "एग्जिट-कंट्रोल्ड लूप शर्त की परवाह किए बिना प्रारंभिक निष्पादन सुनिश्चित करते हैं।"
      }
    },
    {
      "question_id": 27,
      "question": {
        "en": "Dry Run: Calculate the final 'Area' after this trace:\n\nDECLARE\n  Rad NUMBER := 10;\n  Ar NUMBER;\nBEGIN\n  Ar := 3.14 * POWER(Rad, 2);\nEND;",
        "hi": "ड्राय रन: इस ट्रेस के बाद अंतिम 'Area' की गणना करें:\n\nDECLARE\n  Rad NUMBER := 10;\n  Ar NUMBER;\nBEGIN\n  Ar := 3.14 * POWER(Rad, 2);\nEND;"
      },
      "options": {
        "a": {"en": "31.4", "hi": "31.4"},
        "b": {"en": "314", "hi": "314"},
        "c": {"en": "628", "hi": "628"},
        "d": {"en": "100", "hi": "100"}
      },
      "correct_option": "b",
      "hint": {
        "en": "POWER(10, 2) is 10*10. Then multiply by 3.14.",
        "hi": "POWER(10, 2) का अर्थ 10*10 है। फिर 3.14 से गुणा करें।"
      },
      "explanation": {
        "en": "Step 1: POWER(10, 2) = 100. Step 2: 3.14 * 100 = 314. The result is 314.",
        "hi": "चरण 1: POWER(10, 2) = 100। चरण 2: 3.14 * 100 = 314। परिणाम 314 है।"
      },
      "key_takeaway": {
        "en": "PL/SQL POWER function is the standard for squaring radius.",
        "hi": "त्रिज्या को वर्ग करने के लिए PL/SQL POWER फंक्शन मानक है।"
      }
    },
    {
      "question_id": 28,
      "question": {
        "en": "How do you correctly declare a constant for PI in PL/SQL?",
        "hi": "PL/SQL में PI के लिए कॉन्स्टेंट को सही ढंग से कैसे घोषित किया जाता है?"
      },
      "options": {
        "a": {"en": "PI CONSTANT NUMBER := 3.14;", "hi": "PI CONSTANT NUMBER := 3.14;"},
        "b": {"en": "VAR PI = 3.14 CONSTANT;", "hi": "VAR PI = 3.14 CONSTANT;"},
        "c": {"en": "DEFINE PI 3.14", "hi": "DEFINE PI 3.14"},
        "d": {"en": "PI := 3.14 CONSTANT;", "hi": "PI := 3.14 CONSTANT;"}
      },
      "correct_option": "a",
      "hint": {
        "en": "The keyword CONSTANT comes immediately after the name.",
        "hi": "CONSTANT कीवर्ड नाम के तुरंत बाद आता है।"
      },
      "explanation": {
        "en": "Standard PL/SQL constant syntax: name CONSTANT type := value;. This value cannot be changed later.",
        "hi": "मानक PL/SQL कॉन्स्टेंट सिंटैक्स: name CONSTANT type := value;। इस मान को बाद में बदला नहीं जा सकता।"
      },
      "key_takeaway": {
        "en": "Constants must be initialized at the time of declaration.",
        "hi": "कॉन्स्टेंट को घोषणा के समय इनिशियलाइज़ किया जाना चाहिए।"
      }
    },
    {
      "question_id": 29,
      "question": {
        "en": "Predict the output of this logic check in PHP: echo (5 == '5' &amp;&amp; 5 === '5');",
        "hi": "PHP में इस लॉजिक चेक के आउटपुट का अनुमान लगाएं: echo (5 == '5' &amp;&amp; 5 === '5');"
      },
      "options": {
        "a": {"en": "true", "hi": "true"},
        "b": {"en": "false", "hi": "false"},
        "c": {"en": "1", "hi": "1"},
        "d": {"en": "Error", "hi": "Error"}
      },
      "correct_option": "b",
      "hint": {
        "en": "=== checks if BOTH value and data-type are exactly the same.",
        "hi": "=== जाँचता है कि क्या मान और डेटा-टाइप दोनों बिल्कुल समान हैं।"
      },
      "explanation": {
        "en": "5 == '5' is TRUE (values match). 5 === '5' is FALSE (one is integer, one is string). Since && requires both to be TRUE, the final result is FALSE.",
        "hi": "5 == '5' TRUE है (मान मिलते हैं)। 5 === '5' FALSE है (एक पूर्णांक है, एक स्ट्रिंग है)। चूंकि && के लिए दोनों का TRUE होना आवश्यक है, इसलिए अंतिम परिणाम FALSE है।"
      },
      "key_takeaway": {
        "en": "Strict equality (===) does not allow type conversion.",
        "hi": "सख्त समानता (===) डेटा-टाइप परिवर्तन की अनुमति नहीं देती है।"
      }
    },
    {
      "question_id": 30,
      "question": {
        "en": "In a PL/SQL CASE statement, what is the correct keyword for the fallback (none of the above) logic?",
        "hi": "PL/SQL CASE स्टेटमेंट में, फॉलबैक (उपरोक्त में से कोई नहीं) लॉजिक के लिए सही कीवर्ड क्या है?"
      },
      "options": {
        "a": {"en": "DEFAULT", "hi": "DEFAULT"},
        "b": {"en": "ELSE", "hi": "ELSE"},
        "c": {"en": "OTHERWISE", "hi": "OTHERWISE"},
        "d": {"en": "EXCEPTION", "hi": "EXCEPTION"}
      },
      "correct_option": "b",
      "hint": {
        "en": "It is the same keyword used in IF-ELSE.",
        "hi": "यह वही कीवर्ड है जो IF-ELSE में उपयोग किया जाता है।"
      },
      "explanation": {
        "en": "PL/SQL CASE syntax uses 'ELSE' before 'END CASE;' to handle situations where no 'WHEN' condition matches.",
        "hi": "PL/SQL CASE सिंटैक्स 'END CASE;' से पहले 'ELSE' का उपयोग करता है ताकि उन स्थितियों को संभाला जा सके जहाँ कोई 'WHEN' शर्त मेल नहीं खाती।"
      },
      "key_takeaway": {
        "en": "CASE structure: WHEN...THEN...ELSE...END CASE;.",
        "hi": "CASE संरचना: WHEN...THEN...ELSE...END CASE;।"
      }
    },
    {
      "question_id": 31,
      "question": {
        "en": "What will be printed if $m = 32 in this PHP Grading code?\n\nif ($m &gt;= 85) { echo 'A'; }\nelseif ($m &gt;= 33) { echo 'B'; }\nelse { echo 'F'; }",
        "hi": "यदि इस PHP ग्रेडिंग कोड में $m = 32 है तो क्या प्रिंट होगा?\n\nif ($m &gt;= 85) { echo 'A'; }\nelseif ($m &gt;= 33) { echo 'B'; }\nelse { echo 'F'; }"
      },
      "options": {
        "a": {"en": "A", "hi": "A"},
        "b": {"en": "B", "hi": "B"},
        "c": {"en": "F", "hi": "F"},
        "d": {"en": "Error", "hi": "Error"}
      },
      "correct_option": "c",
      "hint": {
        "en": "Check if 32 is greater than 33.",
        "hi": "जाँचें कि क्या 32, 33 से बड़ा है।"
      },
      "explanation": {
        "en": "32 is less than 85 and also less than 33. All if/elseif conditions fail, so the final 'else' executes.",
        "hi": "32, 85 से कम है और 33 से भी कम है। सभी if/elseif शर्तें विफल हो जाती हैं, इसलिए अंतिम 'else' निष्पादित होता है।"
      },
      "key_takeaway": {
        "en": "The final 'else' is a catch-all for anything not covered by previous conditions.",
        "hi": "अंतिम 'else' उन सभी चीज़ों के लिए है जो पिछली शर्तों में शामिल नहीं हैं।"
      }
    },
    {
      "question_id": 32,
      "question": {
        "en": "Dry Run: What is the last value of 'i' printed by this reverse loop?\n\nDECLARE\n  i NUMBER;\nBEGIN\n  FOR i IN REVERSE 1..3 LOOP\n    DBMS_OUTPUT.PUT_LINE(i);\n  END LOOP;\nEND;",
        "hi": "ड्राय रन: इस रिवर्स लूप द्वारा प्रिंट किया गया 'i' का अंतिम मान क्या है?\n\nDECLARE\n  i NUMBER;\nBEGIN\n  FOR i IN REVERSE 1..3 LOOP\n    DBMS_OUTPUT.PUT_LINE(i);\n  END LOOP;\nEND;"
      },
      "options": {
        "a": {"en": "3", "hi": "3"},
        "b": {"en": "1", "hi": "1"},
        "c": {"en": "0", "hi": "0"},
        "d": {"en": "2", "hi": "2"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Trace the countdown: 3, 2, ...?",
        "hi": "काउंटडाउन को ट्रेस करें: 3, 2, ...?"
      },
      "explanation": {
        "en": "The loop runs backwards from 3 to 1. Iteration 1: 3. Iteration 2: 2. Iteration 3: 1. The last value printed is 1.",
        "hi": "लूप 3 से 1 तक उल्टा चलता है। राउंड 1: 3। राउंड 2: 2। राउंड 3: 1। प्रिंट किया गया अंतिम मान 1 है।"
      },
      "key_takeaway": {
        "en": "REVERSE keyword counts from higher bound to lower bound.",
        "hi": "REVERSE कीवर्ड उच्च सीमा से निम्न सीमा तक गिनती करता है।"
      }
    },
    {
      "question_id": 33,
      "question": {
        "en": "Predict the result of the following PHP operation: echo (2 + 3 * 4);",
        "hi": "निम्नलिखित PHP संक्रिया के परिणाम का अनुमान लगाएं: echo (2 + 3 * 4);"
      },
      "options": {
        "a": {"en": "20", "hi": "20"},
        "b": {"en": "14", "hi": "14"},
        "c": {"en": "9", "hi": "9"},
        "d": {"en": "234", "hi": "234"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Multiplication has higher precedence than addition.",
        "hi": "गुणा को जोड़ से अधिक प्राथमिकता दी जाती है।"
      },
      "explanation": {
        "en": "First multiply 3 and 4 (12), then add 2. Total is 14.",
        "hi": "पहले 3 और 4 को गुणा करें (12), फिर 2 जोड़ें। कुल 14 है।"
      },
      "key_takeaway": {
        "en": "Order of operations (BODMAS/PEMDAS) is crucial in programming calculations.",
        "hi": "प्रोग्रामिंग गणनाओं में संक्रियाओं का क्रम (BODMAS) अत्यंत महत्वपूर्ण है।"
      }
    },
    {
      "question_id": 34,
      "question": {
        "en": "Identify the missing logic in this Fibonacci program step:\n\n$SUM = $PRV + $NXT;\n$PRV = ______;\n$NXT = $SUM;",
        "hi": "इस फाइबोनैचि प्रोग्राम चरण में गायब लॉजिक की पहचान करें:\n\n$SUM = $PRV + $NXT;\n$PRV = ______;\n$NXT = $SUM;"
      },
      "options": {
        "a": {"en": "$SUM", "hi": "$SUM"},
        "b": {"en": "$NXT", "hi": "$NXT"},
        "c": {"en": "$N", "hi": "$N"},
        "d": {"en": "0", "hi": "0"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Before NXT takes the new sum, PRV must take the current NXT.",
        "hi": "NXT द्वारा नया योग लेने से पहले, PRV को वर्तमान NXT मान लेना चाहिए।"
      },
      "explanation": {
        "en": "To continue the series, the current number becomes the previous number for the next round. So $PRV = $NXT.",
        "hi": "सीरीज जारी रखने के लिए, वर्तमान संख्या अगले दौर के लिए पिछली संख्या बन जाती है। इसलिए $PRV = $NXT।"
      },
      "key_takeaway": {
        "en": "Swapping/Shifting values is essential for sequence generation.",
        "hi": "अनुक्रम निर्माण के लिए मानों को स्वैप या शिफ्ट करना आवश्यक है।"
      }
    },
    {
      "question_id": 35,
      "question": {
        "en": "Which statement correctly checks if a number 'n' is divisible by both 2 and 3 in PL/SQL?",
        "hi": "PL/SQL में कौन सा स्टेटमेंट सही ढंग से जाँचता है कि क्या कोई संख्या 'n' 2 और 3 दोनों से विभाज्य है?"
      },
      "options": {
        "a": {"en": "IF (MOD(n, 2) = 0 OR MOD(n, 3) = 0)", "hi": "IF (MOD(n, 2) = 0 OR MOD(n, 3) = 0)"},
        "b": {"en": "IF (MOD(n, 2) = 0 AND MOD(n, 3) = 0)", "hi": "IF (MOD(n, 2) = 0 AND MOD(n, 3) = 0)"},
        "c": {"en": "IF (n % 2 == 0 &amp;&amp; n % 3 == 0)", "hi": "IF (n % 2 == 0 &amp;&amp; n % 3 == 0)"},
        "d": {"en": "IF (n / 2 = 0 AND n / 3 = 0)", "hi": "IF (n / 2 = 0 AND n / 3 = 0)"}
      },
      "correct_option": "b",
      "hint": {
        "en": "Both remainders must be zero. Use AND for both conditions.",
        "hi": "दोनों शेषफल शून्य होने चाहिए। दोनों शर्तों के लिए AND का उपयोग करें।"
      },
      "explanation": {
        "en": "To check divisibility by multiple numbers, each MOD result must be zero, and they must be joined by the AND operator.",
        "hi": "कई संख्याओं द्वारा विभाज्यता जाँचने के लिए, प्रत्येक MOD परिणाम शून्य होना चाहिए, और उन्हें AND ऑपरेटर द्वारा जोड़ा जाना चाहिए।"
      },
      "key_takeaway": {
        "en": "Multiple divisibility logic requires logical conjunction (AND).",
        "hi": "मल्टीपल विभाज्यता लॉजिक के लिए लॉजिकल कंजंक्शन (AND) की आवश्यकता होती है।"
      }
    }
  ]
}
